[{"/Users/josephiannone/Documents/Dev/p2p-chat/src/index.tsx":"1","/Users/josephiannone/Documents/Dev/p2p-chat/src/serviceWorkerRegistration.ts":"2","/Users/josephiannone/Documents/Dev/p2p-chat/src/reportWebVitals.ts":"3","/Users/josephiannone/Documents/Dev/p2p-chat/src/App.tsx":"4","/Users/josephiannone/Documents/Dev/p2p-chat/src/components/Chat.tsx":"5","/Users/josephiannone/Documents/Dev/p2p-chat/src/components/LoginForm.tsx":"6"},{"size":836,"mtime":1610258211005,"results":"7","hashOfConfig":"8"},{"size":5256,"mtime":1610063020751,"results":"9","hashOfConfig":"8"},{"size":425,"mtime":1610063020751,"results":"10","hashOfConfig":"8"},{"size":662,"mtime":1610246728307,"results":"11","hashOfConfig":"8"},{"size":11218,"mtime":1610257894721,"results":"12","hashOfConfig":"8"},{"size":2663,"mtime":1610254269637,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"15w35w3",{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"18"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/josephiannone/Documents/Dev/p2p-chat/src/index.tsx",[],"/Users/josephiannone/Documents/Dev/p2p-chat/src/serviceWorkerRegistration.ts",[],["28","29"],"/Users/josephiannone/Documents/Dev/p2p-chat/src/reportWebVitals.ts",[],"/Users/josephiannone/Documents/Dev/p2p-chat/src/App.tsx",[],"/Users/josephiannone/Documents/Dev/p2p-chat/src/components/Chat.tsx",["30","31","32","33","34"],"import { Component } from 'react'\nimport Peer from 'peerjs' \nimport moment from 'moment';\nimport { Icon, Box, Badge, Button, List, ListItem, ListItemText, ListItemIcon, SwipeableDrawer } from '@material-ui/core';\nimport CommentIcon from '@material-ui/icons/Comment';\nimport FiberManualRecordIcon from '@material-ui/icons/FiberManualRecord';\nimport AccountCircleIcon from '@material-ui/icons/AccountCircle';\nimport Grid from '@material-ui/core/Grid';\nimport '../style/Chat.css';\n\n\ntype ChatProps = {\n  localPeer: Peer\n}\n\ninterface Connections {\n  [key: string]: any\n}\n\ninterface User {\n  username: string,\n  peerID: string,\n  _id: string\n}\n\ninterface Message {\n  message: { username: string, message: string},\n  from: string,\n  timestamp: moment.Moment,\n  seen: Boolean\n}\n\ninterface Messages {\n  [key: string]: Message[]\n}\n\ntype ChatState = {\n  remotePeers: User[],\n  localPeer: Peer,\n  localPeerID: string,\n  selectedRemotePeer: User,\n  textMessage: string,\n  connections: Connections,\n  messages: Messages,\n  isLoggedIn: Boolean,\n  username: string\n\n}\n\n/************************************************************************\n * This component handles remote peer discovdery, connections, and \n * messages between peers\n */\nclass Chat extends Component<ChatProps, ChatState> {\n\n  // variable to hold interval for remote peer discovery\n  private updateRemotePeersInterval : number = 0;\n  \n  constructor(props: ChatProps | Readonly<ChatProps>) {\n\n    super(props);\n\n    this.state = {\n      remotePeers: [],\n      localPeer: this.props.localPeer,\n      localPeerID: '',\n      selectedRemotePeer: {username: '', peerID: '', _id: ''},\n      textMessage: '',\n      connections: {},\n      messages: {},\n      isLoggedIn: false,\n      username: ''\n    };\n\n    this.handleRemotePeerChange = this.handleRemotePeerChange.bind(this);\n    this.connectToPeer = this.connectToPeer.bind(this);\n    this.sendMessage = this.sendMessage.bind(this);\n    this.handleMessageChange = this.handleMessageChange.bind(this);\n    this.updateSeenStateOnPeerMessages = this.updateSeenStateOnPeerMessages.bind(this);\n  }\n\n  componentDidMount() {\n\n\n    /**\n     * Check if logged in\n     */\n    fetch(\"/check\")\n    .then(res => res.json())\n    .then((result) => {\n      if (this.exists(result.username)) {\n        this.setState({ isLoggedIn: true, username: result.username });\n      } else {\n        window.location.href = \"/login\";\n      }\n    }, (error) => {\n      window.location.href = \"/login\";\n    })\n\n    let messages: string|null = localStorage.getItem('messages');\n    if (messages !== null) this.setState({messages: JSON.parse(messages)});\n    \n    // get local peer id from peer server\n    this.state.localPeer.on('open', (peerid) => {\n      this.setState({localPeerID: peerid});\n      //assocciate peer id to username on server side\n      this.setUserPeerID(peerid);\n      // retrieve remote peers\n      this.getRemotePeers();\n    });\n\n    // listen for connections\n    this.state.localPeer.on('connection', (conn) => {\n\n      // message receiver\n      conn.on('data', (data) => {\n        // received\n        this.updateRemotePeerMessages(data.username, data.message, data.username);\n      });\n      \n      // connection receiver\n      conn.on('open', () => {\n        // connected\n        //if (!this.exists(this.state.connections[conn.peer])) conn.send(`Connection opened with ${this.state.localPeerID}`);\n        this.state.remotePeers.find((peer, index) => {\n          if (peer.peerID === conn.peer) this.updateRemotePeerConnections(peer.username, conn);\n        });\n        \n      });\n\n    });\n\n    // update remote peers list every second\n    this.updateRemotePeersInterval = window.setInterval(() => {\n      this.getRemotePeers();\n    }, 1000);\n\n\n  }\n\n  componentWillUnmount() {\n    // clear this interval before unmounting\n    clearInterval(this.updateRemotePeersInterval);\n  }\n\n  /**\n   * Peer discovery method\n   */\n  getRemotePeers() {\n    fetch(\"/peers\")\n      .then(res => res.json())\n      .then(\n        (result) => {\n          this.setState({\n            remotePeers: result\n          });\n        },\n        (error) => {\n          console.log(error);\n        }\n      )\n  }\n\n  setUserPeerID(peerid: string) {\n    fetch('/updatepeerid', {\n      method: 'POST', \n      body: JSON.stringify({ \n        username: this.state.username,\n        peerid: peerid\n      }), \n      headers: {'Content-Type': 'application/json'}\n    })\n    .then(response => response.json())\n    .then(result => {\n      console.log('Success:', result);\n    })\n    .catch(error => {\n      console.error('Error:', error);\n    });\n  }\n\n  updateSeenStateOnPeerMessages(peer: User) {\n    if (this.exists(this.state.messages[peer.username])) {\n      var messages = this.state.messages;\n      // update seen state of messages from this peer\n      let peerMessages = messages[peer.username];\n      messages[peer.username].forEach((message, index) => { messages[peer.username][index].seen = true; } )\n      this.setState({messages: messages});\n      //localStorage.setItem('messages', JSON.stringify(messages));\n    }\n  }\n\n  \n  handleRemotePeerChange = (event: React.MouseEvent, peer: User) => {\n    this.setState({selectedRemotePeer: peer});\n    this.updateSeenStateOnPeerMessages(peer);\n    this.connectToPeer(peer);\n  }\n\n  updateRemotePeerConnections(username: string, conn: Object) {\n    \n    let connections: Connections = this.state.connections;\n    connections[username] = conn;\n    this.setState({connections: connections});\n\n    console.log(this.state.connections);\n    \n  }\n\n  updateRemotePeerMessages(username: string, textMessage: string, remotePeerIndex: string) {\n    \n    let messages: Messages = this.state.messages;\n\n    if (!this.exists(messages[remotePeerIndex])) messages[remotePeerIndex] = [];\n\n    messages[remotePeerIndex].push({\n      message: {message: textMessage, username: username}, \n      timestamp: moment(), \n      from: username, \n      seen: (this.state.selectedRemotePeer.username === username)\n    });\n    \n    this.setState({messages: messages});\n    //localStorage.setItem('messages', JSON.stringify(messages));\n  }\n\n  connectToPeer(user: User) {\n    \n    var conn = this.props.localPeer.connect(user.peerID);\n \n    conn.on('open', () => {\n      //if (!this.exists(this.state.connections[remotePeerID])) conn.send(`<b>Connection opened with ${this.state.localPeerID}</b>`);\n      this.updateRemotePeerConnections(user.username, conn);\n    });\n\n    conn.on('data', (data) => {\n      this.updateRemotePeerMessages(data.username, data.message, data.username);\n      console.log(conn.peer, this.state.messages[conn.peer]);\n    });\n    \n  }\n\n  sendMessage = (event: React.MouseEvent) => {\n    this.state.connections[this.state.selectedRemotePeer.username].send({username: this.state.username, message: this.state.textMessage});\n    this.updateRemotePeerMessages(this.state.username, this.state.textMessage, this.state.selectedRemotePeer.username);\n    this.setState({textMessage: ''});\n  }\n\n\n  handleMessageChange = (event: React.ChangeEvent) => {\n    this.setState({textMessage: (event.target as HTMLInputElement).value});\n  }\n\n  \n  exists(v: any) {\n    if (typeof v !== 'undefined') return true;\n    else return false;\n  }\n\n\n  render() {\n\n    const { username, remotePeers, localPeerID, connections, textMessage, selectedRemotePeer, messages } = this.state;\n    \n    return (\n      <Grid container spacing={0}>\n\n        <Grid item xs={12} sm={8}>\n          <Box id='chat-window-container' >\n            <Box id='chat-window'>\n              <List>\n              {this.exists(connections[selectedRemotePeer.username]) ? \n                <ListItem dense style={{color: 'green'}}>Connection opened with <b>&nbsp;{selectedRemotePeer.username}</b></ListItem> : \n                <></>\n              }\n              {this.exists(messages[selectedRemotePeer.username]) ?\n              <>\n              {messages[selectedRemotePeer.username].map((message) => {\n                return (\n                  <ListItem dense key={JSON.stringify(message)}>\n                    <Grid container justify=\"flex-start\" direction=\"row\">\n                      <Grid item xs={1}><AccountCircleIcon style={{float: 'left'}} color={message.from === username ? 'primary':'secondary'} fontSize={'large'} /></Grid>\n                      <Grid item xs={11} className={'messageDisplaycontainer'}>\n                        <div>\n                          <span className='messageDisplayName'>{message.from}</span>\n                          <span className='messageDisplayTS'>{message.timestamp.format('M/D/YY h:mm a')}</span>\n                        </div>\n                        <div className='messageDisplayMSG'>{message.message.message}</div>  \n                      </Grid>\n                    </Grid>\n                    \n\n                   \n                  </ListItem>\n                );\n              })}\n              </> : ''\n              }\n              </List>\n            </Box>\n            {this.exists(connections[selectedRemotePeer.username]) ?\n            <Box boxShadow={1} id={'text-send-region-container'}>\n              <Grid container spacing={0} id={'text-send-container'}>\n                <Grid item xs={8}><textarea style={{width: '100%', resize: 'none'}} value={textMessage} onChange={this.handleMessageChange} rows={2}></textarea></Grid>\n                <Grid item xs={2}><Button disableElevation variant=\"contained\" color='primary' onClick={this.sendMessage} >Send</Button></Grid>\n              </Grid>\n            </Box> : ''\n            }            \n          </Box>\n        </Grid>\n        <Grid item xs={12} sm={4} style={{borderLeft: '1px #d3d3d3 solid'}} >\n          \n            \n          <List disablePadding>\n          {(remotePeers.length < 2) ? \n            <ListItem disabled>No Peers Available</ListItem> :\n            <>\n            {remotePeers.map((peer: User) => {\n              if (peer.username === username) return '';\n              \n              var unreadCount = 0;\n              var hasMessages = false;\n              if (this.exists(messages[peer.username])) {\n                hasMessages = true;\n                unreadCount = messages[peer.username].filter((message) => peer.username === message.from ? message.seen === false : false).length;\n              }\n\n              return (\n                <ListItem key={JSON.stringify(peer)} dense button selected={selectedRemotePeer.username === peer.username} onClick={(event) => this.handleRemotePeerChange(event, peer)}>\n                {this.exists(connections[peer.username]) ? \n                  <>\n                  <ListItemIcon>\n                    <FiberManualRecordIcon fontSize='small' style={{color: 'green'}} />\n                  </ListItemIcon>\n                  <ListItemText primary={peer.username} />\n                  {hasMessages ? <Badge badgeContent={unreadCount} color=\"secondary\"><CommentIcon fontSize='small' color='primary' /></Badge> : ''} \n                  </>: \n                  <ListItemText primary={peer.username} />\n                }\n                </ListItem>\n              )\n            })}\n            </>\n          }\n          </List>\n        </Grid>\n        \n\n      </Grid>\n    );\n  }\n\n}\n\n\n\nexport default Chat;","/Users/josephiannone/Documents/Dev/p2p-chat/src/components/LoginForm.tsx",[],{"ruleId":"35","replacedBy":"36"},{"ruleId":"37","replacedBy":"38"},{"ruleId":"39","severity":1,"message":"40","line":4,"column":10,"nodeType":"41","messageId":"42","endLine":4,"endColumn":14},{"ruleId":"39","severity":1,"message":"43","line":4,"column":80,"nodeType":"41","messageId":"42","endLine":4,"endColumn":95},{"ruleId":"44","severity":1,"message":"45","line":125,"column":51,"nodeType":"46","messageId":"47","endLine":125,"endColumn":53},{"ruleId":"39","severity":1,"message":"48","line":186,"column":11,"nodeType":"41","messageId":"42","endLine":186,"endColumn":23},{"ruleId":"39","severity":1,"message":"49","line":263,"column":36,"nodeType":"41","messageId":"42","endLine":263,"endColumn":47},"no-native-reassign",["50"],"no-negated-in-lhs",["51"],"@typescript-eslint/no-unused-vars","'Icon' is defined but never used.","Identifier","unusedVar","'SwipeableDrawer' is defined but never used.","array-callback-return","Array.prototype.find() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","'peerMessages' is assigned a value but never used.","'localPeerID' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]