[{"/home/joe/Dev/p2p-chat/src/index.tsx":"1","/home/joe/Dev/p2p-chat/src/reportWebVitals.ts":"2","/home/joe/Dev/p2p-chat/src/serviceWorkerRegistration.ts":"3","/home/joe/Dev/p2p-chat/src/App.tsx":"4","/home/joe/Dev/p2p-chat/src/components/Chat.tsx":"5"},{"size":794,"mtime":1610115029232,"results":"6","hashOfConfig":"7"},{"size":425,"mtime":1609702908330,"results":"8","hashOfConfig":"7"},{"size":5256,"mtime":1609702908332,"results":"9","hashOfConfig":"7"},{"size":341,"mtime":1610129309840,"results":"10","hashOfConfig":"7"},{"size":9845,"mtime":1610227837350,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"qoxqi7",{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23"},"/home/joe/Dev/p2p-chat/src/index.tsx",[],["24","25"],"/home/joe/Dev/p2p-chat/src/reportWebVitals.ts",[],"/home/joe/Dev/p2p-chat/src/serviceWorkerRegistration.ts",[],"/home/joe/Dev/p2p-chat/src/App.tsx",[],"/home/joe/Dev/p2p-chat/src/components/Chat.tsx",["26","27","28"],"import { Component } from 'react'\nimport Peer from 'peerjs' \nimport moment from 'moment';\nimport { Box, Badge, Button, List, ListItem, ListItemText, ListItemIcon, SwipeableDrawer } from '@material-ui/core';\nimport CommentIcon from '@material-ui/icons/Comment';\nimport FiberManualRecordIcon from '@material-ui/icons/FiberManualRecord';\nimport AccountCircleIcon from '@material-ui/icons/AccountCircle';\nimport Grid from '@material-ui/core/Grid';\nimport '../style/Chat.css';\n\n\ntype ChatProps = {\n  localPeer: Peer\n}\n\ninterface Connections {\n  [key: string]: any\n}\n\ninterface Message {\n  message: string,\n  fromPeerID: string,\n  timestamp: moment.Moment,\n  seen: Boolean\n}\n\ninterface User {\n  PeerID: string,\n  username: string,\n  userkey: string,\n}\n\ninterface Messages {\n  [key: string]: Message[]\n}\n\ntype ChatState = {\n  remotePeers: string[],\n  localPeer: Peer,\n  localPeerID: string,\n  selectedRemotePeerID: string,\n  textMessage: string,\n  connections: Connections,\n  messages: Messages\n\n}\n\n/************************************************************************\n * This component handles remote peer discovdery, connections, and \n * messages between peers\n */\nclass Chat extends Component<ChatProps, ChatState> {\n\n  // variable to hold interval for remote peer discovery\n  private updateRemotePeersInterval : number = 0;\n  \n  constructor(props: ChatProps | Readonly<ChatProps>) {\n\n    super(props);\n\n    this.state = {\n      remotePeers: [],\n      localPeer: this.props.localPeer,\n      localPeerID: '',\n      selectedRemotePeerID: '',\n      textMessage: '',\n      connections: {},\n      messages: {}\n    };\n\n    this.handleRemotePeerChange = this.handleRemotePeerChange.bind(this);\n    this.connectToPeer = this.connectToPeer.bind(this);\n    this.sendMessage = this.sendMessage.bind(this);\n    this.handleMessageChange = this.handleMessageChange.bind(this);\n    this.updateSeenStateOnPeerMessages = this.updateSeenStateOnPeerMessages.bind(this);\n  }\n\n  componentDidMount() {\n\n    let messages: string|null = localStorage.getItem('messages');\n    if (messages !== null) this.setState({messages: JSON.parse(messages)});\n    \n    // get local peer id from peer server\n    this.state.localPeer.on('open', (peerid) => {\n      this.setState({localPeerID: peerid});\n      // retrieve remote peers\n      this.getRemotePeers();\n    });\n\n    // listen for connections\n    this.state.localPeer.on('connection', (conn) => {\n\n      // message receiver\n      conn.on('data', (data) => {\n        // received\n        this.updateRemotePeerMessages(conn.peer, data, conn.peer);\n      });\n      \n      // connection receiver\n      conn.on('open', () => {\n        // connected\n        //if (!this.exists(this.state.connections[conn.peer])) conn.send(`Connection opened with ${this.state.localPeerID}`);\n        this.updateRemotePeerConnections(conn.peer, conn);\n      });\n\n    });\n\n    // update remote peers list every second\n    this.updateRemotePeersInterval = window.setInterval(() => {\n      this.getRemotePeers();\n    }, 1000);\n\n\n  }\n\n  componentWillUnmount() {\n    // clear this interval before unmounting\n    clearInterval(this.updateRemotePeersInterval);\n  }\n\n  /**\n   * Peer discovery method\n   */\n  getRemotePeers() {\n    fetch(\"/peerserver/peerjs/peers\")\n      .then(res => res.json())\n      .then(\n        (result) => {\n          this.setState({\n            remotePeers: result\n          });\n        },\n        (error) => {\n          console.log(error);\n        }\n      )\n  }\n\n  updateSeenStateOnPeerMessages(peerID: string) {\n    if (this.exists(this.state.messages[peerID])) {\n      var messages = this.state.messages;\n      // update seen state of messages from this peer\n      let peerMessages = messages[peerID];\n      messages[peerID].forEach((message, index) => { messages[peerID][index].seen = true; } )\n      this.setState({messages: messages});\n      localStorage.setItem('messages', JSON.stringify(messages));\n    }\n  }\n\n  \n  handleRemotePeerChange = (event: React.MouseEvent, peerID: string) => {\n    this.setState({selectedRemotePeerID: peerID});\n    this.updateSeenStateOnPeerMessages(peerID);\n    this.connectToPeer(peerID);\n  }\n\n  updateRemotePeerConnections(remotePeerID: string, conn: Object) {\n    \n    let connections: Connections = this.state.connections;\n    connections[remotePeerID] = conn;\n    this.setState({connections: connections});\n    \n  }\n\n  updateRemotePeerMessages(fromPeerID: string, textMessage: string, remotePeerIndex: string) {\n    \n    let messages: Messages = this.state.messages;\n\n    if (!this.exists(messages[remotePeerIndex])) messages[remotePeerIndex] = [];\n\n    messages[remotePeerIndex].push({\n      message: textMessage, \n      timestamp: moment(), \n      fromPeerID: fromPeerID, \n      seen: (this.state.selectedRemotePeerID === fromPeerID)\n    });\n    \n    this.setState({messages: messages});\n    localStorage.setItem('messages', JSON.stringify(messages));\n  }\n\n  connectToPeer(remotePeerID: string) {\n    \n    var conn = this.props.localPeer.connect(remotePeerID);\n \n    conn.on('open', () => {\n      //if (!this.exists(this.state.connections[remotePeerID])) conn.send(`<b>Connection opened with ${this.state.localPeerID}</b>`);\n      this.updateRemotePeerConnections(remotePeerID, conn);\n    });\n\n    conn.on('data', (data) => {\n      this.updateRemotePeerMessages(conn.peer, data, conn.peer);\n      console.log(conn.peer, this.state.messages[conn.peer]);\n    });\n    \n  }\n\n  sendMessage = (event: React.MouseEvent) => {\n    this.state.connections[this.state.selectedRemotePeerID].send(this.state.textMessage);\n    this.updateRemotePeerMessages(this.state.localPeerID, this.state.textMessage, this.state.selectedRemotePeerID);\n    this.setState({textMessage: ''});\n  }\n\n\n  handleMessageChange = (event: React.ChangeEvent) => {\n    this.setState({textMessage: (event.target as HTMLInputElement).value});\n  }\n\n  \n  exists(v: any) {\n    if (typeof v !== 'undefined') return true;\n    else return false;\n  }\n\n\n  render() {\n\n    const { remotePeers, localPeerID, connections, textMessage, selectedRemotePeerID, messages } = this.state;\n    \n    return (\n      <Grid container spacing={0}>\n\n        <Grid item xs={12} sm={8}>\n          <Box id='chat-window-container' >\n            <Box id='chat-window'>\n              <List>\n              {this.exists(connections[selectedRemotePeerID]) ? \n                <ListItem dense style={{color: 'green'}}>Connection opened with <b>&nbsp;{selectedRemotePeerID}</b></ListItem> : \n                <></>\n              }\n              {this.exists(messages[selectedRemotePeerID]) ?\n              <>\n              {messages[selectedRemotePeerID].map((message) => {\n                return (\n                  <ListItem dense key={JSON.stringify(message)}>\n                    <Grid container justify=\"flex-start\" direction=\"row\">\n                      <Grid item xs={1}><AccountCircleIcon style={{float: 'left'}} color={message.fromPeerID === localPeerID ? 'primary':'secondary'} fontSize={'large'} /></Grid>\n                      <Grid item xs={11} className={'messageDisplaycontainer'}>\n                        <div>\n                          <span className='messageDisplayName'>{message.fromPeerID}</span>\n                          <span className='messageDisplayTS'>{message.timestamp.format('M/D/YY h:mm a')}</span>\n                        </div>\n                        <div className='messageDisplayMSG'>{message.message}</div>  \n                      </Grid>\n                    </Grid>\n                    \n\n                   \n                  </ListItem>\n                );\n              })}\n              </> : ''\n              }\n              </List>\n            </Box>\n            {this.exists(connections[selectedRemotePeerID]) ?\n            <Box boxShadow={1} id={'text-send-region-container'}>\n              <Grid container spacing={0} id={'text-send-container'}>\n                <Grid item xs={8}><textarea style={{width: '100%', resize: 'none'}} value={textMessage} onChange={this.handleMessageChange} rows={2}></textarea></Grid>\n                <Grid item xs={2}><Button disableElevation variant=\"contained\" color='primary' onClick={this.sendMessage}>Send</Button></Grid>\n              </Grid>\n            </Box> : ''\n            }            \n          </Box>\n        </Grid>\n        <Grid item xs={12} sm={4} style={{borderLeft: '1px #d3d3d3 solid'}} >\n          \n            \n          <List disablePadding>\n          {(remotePeers.length < 2) ? \n            <ListItem disabled>No Peers Available</ListItem> :\n            <>\n            {remotePeers.map((peerID: string) => {\n              if (peerID === localPeerID) return '';\n              \n              var unreadCount = 0;\n              var hasMessages = false;\n              if (this.exists(messages[peerID])) {\n                hasMessages = true;\n                unreadCount = messages[peerID].filter((message) => peerID === message.fromPeerID ? message.seen === false : false).length;\n              }\n\n              return (\n                <ListItem dense button selected={selectedRemotePeerID === peerID} onClick={(event) => this.handleRemotePeerChange(event, peerID)}>\n                {this.exists(connections[peerID]) ? \n                  <>\n                  <ListItemIcon>\n                    <FiberManualRecordIcon fontSize='small' style={{color: 'green'}} />\n                  </ListItemIcon>\n                  <ListItemText primary={peerID} />\n                  {hasMessages ? <Badge badgeContent={unreadCount} color=\"secondary\"><CommentIcon fontSize='small' color='primary' /></Badge> : ''} \n                  </>: \n                  <ListItemText primary={peerID} />\n                }\n                </ListItem>\n              )\n            })}\n            </>\n          }\n          </List>\n        </Grid>\n        \n\n      </Grid>\n    );\n  }\n\n}\n\n\n\nexport default Chat;",{"ruleId":"29","replacedBy":"30"},{"ruleId":"31","replacedBy":"32"},{"ruleId":"33","severity":1,"message":"34","line":4,"column":74,"nodeType":"35","messageId":"36","endLine":4,"endColumn":89},{"ruleId":"33","severity":1,"message":"37","line":27,"column":11,"nodeType":"35","messageId":"36","endLine":27,"endColumn":15},{"ruleId":"33","severity":1,"message":"38","line":143,"column":11,"nodeType":"35","messageId":"36","endLine":143,"endColumn":23},"no-native-reassign",["39"],"no-negated-in-lhs",["40"],"@typescript-eslint/no-unused-vars","'SwipeableDrawer' is defined but never used.","Identifier","unusedVar","'User' is defined but never used.","'peerMessages' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]