[{"/home/joe/Dev/p2p-chat/src/index.tsx":"1","/home/joe/Dev/p2p-chat/src/serviceWorkerRegistration.ts":"2","/home/joe/Dev/p2p-chat/src/reportWebVitals.ts":"3","/home/joe/Dev/p2p-chat/src/App.tsx":"4","/home/joe/Dev/p2p-chat/src/components/LoginForm.tsx":"5","/home/joe/Dev/p2p-chat/src/components/Chat.tsx":"6"},{"size":836,"mtime":1610264347454,"results":"7","hashOfConfig":"8"},{"size":5256,"mtime":1609702908332,"results":"9","hashOfConfig":"8"},{"size":425,"mtime":1609702908330,"results":"10","hashOfConfig":"8"},{"size":662,"mtime":1610264347437,"results":"11","hashOfConfig":"8"},{"size":2663,"mtime":1610264347448,"results":"12","hashOfConfig":"8"},{"size":12637,"mtime":1610309233002,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"qoxqi7",{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27"},"/home/joe/Dev/p2p-chat/src/index.tsx",[],["28","29"],"/home/joe/Dev/p2p-chat/src/serviceWorkerRegistration.ts",[],"/home/joe/Dev/p2p-chat/src/reportWebVitals.ts",[],"/home/joe/Dev/p2p-chat/src/App.tsx",[],"/home/joe/Dev/p2p-chat/src/components/LoginForm.tsx",[],"/home/joe/Dev/p2p-chat/src/components/Chat.tsx",["30","31","32","33","34","35","36"],"import React, { useEffect, Component, useState } from 'react'\nimport Peer from 'peerjs' \nimport moment from 'moment';\nimport CryptoJS from 'crypto-js';\nimport { Icon, Box, Badge, Button, List, ListItem, ListItemText, ListItemIcon, SwipeableDrawer } from '@material-ui/core';\nimport CommentIcon from '@material-ui/icons/Comment';\nimport FiberManualRecordIcon from '@material-ui/icons/FiberManualRecord';\nimport AccountCircleIcon from '@material-ui/icons/AccountCircle';\nimport Grid from '@material-ui/core/Grid';\nimport '../style/Chat.css';\n\n\ntype ChatProps = {\n  localPeer: Peer\n}\n\ninterface Connections {\n  [key: string]: any\n}\n\ninterface User {\n  username: string,\n  peerID: string,\n  _id: string\n}\n\ninterface Message {\n  message: { username: string, message: string},\n  from: string,\n  timestamp: string,\n  seen: Boolean\n}\n\ninterface Messages {\n  [key: string]: Message[]\n}\n\ntype ChatState = {\n  remotePeers: User[],\n  localPeer: Peer,\n  localPeerID: string,\n  selectedRemotePeer: User,\n  textMessage: string,\n  connections: Connections,\n  messages: Messages,\n  isLoggedIn: Boolean,\n  username: string\n}\n\n/************************************************************************\n * This component handles remote peer discovdery, connections, and \n * messages between peers\n */\nclass Chat extends Component<ChatProps, ChatState> {\n\n  // variable to hold interval for remote peer discovery\n  private updateRemotePeersInterval : number = 0;\n  private CLIENT_KEY : string = 'AfxKcLYZTn9SWcDZL';\n  private chatWindowRef : React.RefObject<HTMLDivElement>|null  = React.createRef();\n\n  constructor(props: ChatProps | Readonly<ChatProps>) {\n\n    super(props);\n\n    this.state = {\n      remotePeers: [],\n      localPeer: this.props.localPeer,//\n      localPeerID: '',\n      selectedRemotePeer: {username: '', peerID: '', _id: ''},//\n      textMessage: '',//\n      connections: {},\n      messages: {},//\n      isLoggedIn: false,\n      username: '',\n    };\n\n    \n    this.handleRemotePeerChange = this.handleRemotePeerChange.bind(this);\n    this.connectToPeer = this.connectToPeer.bind(this);\n    this.sendMessage = this.sendMessage.bind(this);\n    this.handleMessageChange = this.handleMessageChange.bind(this);\n    this.updateSeenStateOnPeerMessages = this.updateSeenStateOnPeerMessages.bind(this);\n  }\n\n  componentDidMount() {\n    \n\n    /**\n     * Check if logged in\n     */\n    fetch(\"/check\")\n    .then(res => res.json())\n    .then((result) => {\n      if (this.exists(result.username)) {\n        this.setState({ isLoggedIn: true, username: result.username });\n        let messages: string|null = localStorage.getItem(CryptoJS.SHA256(`${result.username}-messages`).toString(CryptoJS.enc.Base64));\n        if (messages !== null) this.setState({messages: JSON.parse(CryptoJS.AES.decrypt(messages, `${this.CLIENT_KEY}${result.username}`).toString(CryptoJS.enc.Utf8))});\n        \n      } else {\n        window.location.href = \"/login\";\n      }\n    }, (error) => {\n      //window.location.href = \"/login\";\n    })\n\n    \n    \n    // get local peer id from peer server\n    this.state.localPeer.on('open', (peerid) => {\n      this.setState({localPeerID: peerid});\n      //assocciate peer id to username on server side\n      this.setUserPeerID(peerid);\n      // retrieve remote peers\n      this.getRemotePeers();\n    });\n\n    // listen for connections\n    this.state.localPeer.on('connection', (conn) => {\n\n      // message receiver\n      conn.on('data', (data) => {\n        // received\n        this.updateRemotePeerMessages(data.username, data.message, data.username);\n      });\n      \n      // connection receiver\n      conn.on('open', () => {\n        // connected\n        //if (!this.exists(this.state.connections[conn.peer])) conn.send(`Connection opened with ${this.state.localPeerID}`);\n        this.state.remotePeers.find((peer, index) => {\n          if (peer.peerID === conn.peer) this.updateRemotePeerConnections(peer.username, conn);\n        });\n        \n      });\n\n    });\n\n    // update remote peers list every second\n    this.updateRemotePeersInterval = window.setInterval(() => {\n      this.getRemotePeers();\n    }, 1000);\n\n\n  }\n\n  scrollToBottom = () => {\n    \n    if (this.chatWindowRef !== null && this.chatWindowRef.current !== null) {\n      this.chatWindowRef.current.scrollIntoView({ behavior: \"smooth\" });\n    }\n  };\n\n  componentWillUnmount() {\n    // clear this interval before unmounting\n    clearInterval(this.updateRemotePeersInterval);\n  }\n\n  /**\n   * Peer discovery method\n   */\n  getRemotePeers() {\n    fetch(\"/peers\")\n    .then(res => res.json())\n    .then((result) => {\n      // establish new connection if there is a change in peerid of existing connection\n      result.map((peer: any) => {\n        if (this.exists(this.state.connections[peer.username])) {\n          if (peer.peerID !== this.state.connections[peer.username].peer) this.connectToPeer(peer);\n        }\n      });\n      if (JSON.stringify(result) !== JSON.stringify(this.state.remotePeers)) this.setState({remotePeers: result});\n    }, (error) => {\n      console.log(error);\n    });\n  }\n\n  setUserPeerID(peerid: string) {\n    fetch('/updatepeerid', {\n      method: 'POST', \n      body: JSON.stringify({ \n        username: this.state.username,\n        peerid: peerid\n      }), \n      headers: {'Content-Type': 'application/json'}\n    })\n    .then(response => response.json())\n    .then(result => {\n      console.log('Success:', result);\n    })\n    .catch(error => {\n      console.error('Error:', error);\n    });\n  }\n\n  updateSeenStateOnPeerMessages(peer: User) {\n    if (this.exists(this.state.messages[peer.username])) {\n      var messages = this.state.messages;\n      // update seen state of messages from this peer\n      let peerMessages = messages[peer.username];\n      messages[peer.username].forEach((message, index) => { messages[peer.username][index].seen = true; } )\n      this.setState({messages: messages}, () => {\n        this.scrollToBottom();\n      });\n      localStorage.setItem(\n        CryptoJS.SHA256(`${this.state.username}-messages`).toString(CryptoJS.enc.Base64), \n        CryptoJS.AES.encrypt(JSON.stringify(messages), `${this.CLIENT_KEY}${this.state.username}`).toString()\n      );\n     \n    }\n  }\n  \n  handleRemotePeerChange = (event: React.MouseEvent, peer: User) => {\n    this.setState({selectedRemotePeer: peer});\n    this.updateSeenStateOnPeerMessages(peer);\n    this.connectToPeer(peer);\n  }\n\n  updateRemotePeerConnections(username: string, conn: Object) {\n    \n    let connections: Connections = this.state.connections;\n    connections[username] = conn;\n    this.setState({connections: connections}, () => {\n      this.scrollToBottom();\n    });\n\n    \n    \n  }\n\n  updateRemotePeerMessages(username: string, textMessage: string, remotePeerIndex: string) {\n    \n    let messages: Messages = this.state.messages;\n\n    if (!this.exists(messages[remotePeerIndex])) messages[remotePeerIndex] = [];\n\n    messages[remotePeerIndex].push({\n      message: {message: textMessage, username: username}, \n      timestamp: moment().format('YYYY-MM-DD HH:mm:ss'), \n      from: username, \n      seen: (this.state.selectedRemotePeer.username === username)\n    });\n    \n    this.setState({messages: messages}, () => {\n      this.scrollToBottom();\n    });\n\n    localStorage.setItem(\n      CryptoJS.SHA256(`${this.state.username}-messages`).toString(CryptoJS.enc.Base64), \n      CryptoJS.AES.encrypt(JSON.stringify(messages), `${this.CLIENT_KEY}${this.state.username}`).toString()\n    );\n    \n  }\n\n  connectToPeer(user: User) {\n    \n    var conn = this.props.localPeer.connect(user.peerID);\n \n    conn.on('open', () => {\n      this.updateRemotePeerConnections(user.username, conn);\n    });\n\n    conn.on('data', (data) => {\n      this.updateRemotePeerMessages(data.username, data.message, data.username);\n      //console.log(conn.peer, this.state.messages[conn.peer]);\n    });\n    \n  }\n\n  sendMessage = (event: React.MouseEvent) => {\n    this.state.connections[this.state.selectedRemotePeer.username].send({username: this.state.username, message: this.state.textMessage});\n    this.updateRemotePeerMessages(this.state.username, this.state.textMessage, this.state.selectedRemotePeer.username);\n    this.setState({textMessage: ''});\n  }\n\n\n  handleMessageChange = (event: React.ChangeEvent) => {\n    this.setState({textMessage: (event.target as HTMLInputElement).value});\n  }\n\n  \n  exists(v: any) {\n    if (typeof v !== 'undefined') return true;\n    else return false;\n  }\n\n\n  render() {\n    \n    const { username, remotePeers, connections, textMessage, selectedRemotePeer, messages } = this.state;\n    \n    return (\n      <Grid container spacing={0}>\n\n        <Grid item xs={12} sm={8}>\n          <Box id='chat-window-container' >\n            <Box id='chat-window'>\n              <List>\n              {this.exists(connections[selectedRemotePeer.username]) ? \n                <ListItem dense style={{color: 'green'}}>Connection opened with <b>&nbsp;{selectedRemotePeer.username}</b></ListItem> : \n                <></>\n              }\n              {this.exists(messages[selectedRemotePeer.username]) ?\n              <>\n              {messages[selectedRemotePeer.username].map((message, index) => {\n                return (\n                  <ListItem dense key={`${JSON.stringify(message)}-${index}`}>\n                    <Grid container justify=\"flex-start\" direction=\"row\">\n                      <Grid item xs={1}><AccountCircleIcon style={{float: 'left'}} color={message.from === username ? 'primary':'secondary'} fontSize={'large'} /></Grid>\n                      <Grid item xs={11} className={'messageDisplaycontainer'}>\n                        <div>\n                          <span className='messageDisplayName'>{message.from}</span>\n                          <span className='messageDisplayTS'>{moment(message.timestamp).format('M/D/YY h:mm a')}</span>\n                        </div>\n                        <div className='messageDisplayMSG'>{message.message.message}</div>  \n                      </Grid>\n                    </Grid>\n                    \n\n                   \n                  </ListItem>\n                );\n\n                \n                \n              })}\n              </> : ''\n              }\n              </List>\n              <div ref={this.chatWindowRef}></div>\n            </Box>\n            {this.exists(connections[selectedRemotePeer.username]) ?\n            <Box boxShadow={1} id={'text-send-region-container'} style={{borderTop: '1px #d3d3d3 solid'}}>\n              <Grid container spacing={0} id={'text-send-container'}>\n                <Grid item xs={8}><textarea style={{width: '100%', resize: 'none'}} value={textMessage} onChange={this.handleMessageChange} rows={2}></textarea></Grid>\n                <Grid item xs={2}><Button disableElevation variant=\"contained\" color='primary' onClick={this.sendMessage} >Send</Button></Grid>\n              </Grid>\n            </Box> : ''\n            }            \n          </Box>\n        </Grid>\n        <Grid item xs={12} sm={4} style={{borderLeft: '1px #d3d3d3 solid'}} >\n          \n            \n          <List key={JSON.stringify(remotePeers)} disablePadding>\n          {(remotePeers.length < 2) ? \n            <ListItem disabled>No Peers Available</ListItem> :\n            <>\n            {remotePeers.map((peer: User) => {\n              if (peer.username === username) return '';\n              \n              var unreadCount = 0;\n              var hasMessages = false;\n              if (this.exists(messages[peer.username])) {\n                hasMessages = true;\n                unreadCount = messages[peer.username].filter((message) => peer.username === message.from ? message.seen === false : false).length;\n              }\n\n              return (\n                <ListItem key={JSON.stringify(peer)} dense button selected={selectedRemotePeer.username === peer.username} onClick={(event) => this.handleRemotePeerChange(event, peer)}>\n                {this.exists(connections[peer.username]) ? \n                  <>\n                  <ListItemIcon>\n                    <FiberManualRecordIcon fontSize='small' style={{color: 'green'}} />\n                  </ListItemIcon>\n                  <ListItemText primary={peer.username} />\n                  {hasMessages ? <Badge badgeContent={unreadCount} color=\"secondary\"><CommentIcon fontSize='small' color='primary' /></Badge> : ''} \n                  </>: \n                  <ListItemText primary={peer.username} />\n                }\n                </ListItem>\n              )\n            })}\n            </>\n          }\n          </List>\n        </Grid>\n        \n\n      </Grid>\n    );\n  }\n\n}\n\n\n\nexport default Chat;",{"ruleId":"37","replacedBy":"38"},{"ruleId":"39","replacedBy":"40"},{"ruleId":"41","severity":1,"message":"42","line":1,"column":17,"nodeType":"43","messageId":"44","endLine":1,"endColumn":26},{"ruleId":"41","severity":1,"message":"45","line":1,"column":39,"nodeType":"43","messageId":"44","endLine":1,"endColumn":47},{"ruleId":"41","severity":1,"message":"46","line":5,"column":10,"nodeType":"43","messageId":"44","endLine":5,"endColumn":14},{"ruleId":"41","severity":1,"message":"47","line":5,"column":80,"nodeType":"43","messageId":"44","endLine":5,"endColumn":95},{"ruleId":"48","severity":1,"message":"49","line":130,"column":51,"nodeType":"50","messageId":"51","endLine":130,"endColumn":53},{"ruleId":"48","severity":1,"message":"52","line":166,"column":30,"nodeType":"50","messageId":"51","endLine":166,"endColumn":32},{"ruleId":"41","severity":1,"message":"53","line":199,"column":11,"nodeType":"43","messageId":"44","endLine":199,"endColumn":23},"no-native-reassign",["54"],"no-negated-in-lhs",["55"],"@typescript-eslint/no-unused-vars","'useEffect' is defined but never used.","Identifier","unusedVar","'useState' is defined but never used.","'Icon' is defined but never used.","'SwipeableDrawer' is defined but never used.","array-callback-return","Array.prototype.find() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","Array.prototype.map() expects a return value from arrow function.","'peerMessages' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]