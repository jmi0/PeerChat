[{"/Users/josephiannone/Documents/Dev/p2p-chat/src/index.tsx":"1","/Users/josephiannone/Documents/Dev/p2p-chat/src/serviceWorkerRegistration.ts":"2","/Users/josephiannone/Documents/Dev/p2p-chat/src/reportWebVitals.ts":"3","/Users/josephiannone/Documents/Dev/p2p-chat/src/App.tsx":"4","/Users/josephiannone/Documents/Dev/p2p-chat/src/components/Chat.tsx":"5","/Users/josephiannone/Documents/Dev/p2p-chat/src/components/LoginForm.tsx":"6","/Users/josephiannone/Documents/Dev/p2p-chat/src/components/Messages.tsx":"7"},{"size":836,"mtime":1610409963842,"results":"8","hashOfConfig":"9"},{"size":5256,"mtime":1610409963843,"results":"10","hashOfConfig":"9"},{"size":425,"mtime":1610409963843,"results":"11","hashOfConfig":"9"},{"size":662,"mtime":1610409963842,"results":"12","hashOfConfig":"9"},{"size":11506,"mtime":1610417836412,"results":"13","hashOfConfig":"9"},{"size":2663,"mtime":1610409963842,"results":"14","hashOfConfig":"9"},{"size":1781,"mtime":1610417624169,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"15w35w3",{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27","usedDeprecatedRules":"18"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"32"},"/Users/josephiannone/Documents/Dev/p2p-chat/src/index.tsx",[],["33","34"],"/Users/josephiannone/Documents/Dev/p2p-chat/src/serviceWorkerRegistration.ts",[],"/Users/josephiannone/Documents/Dev/p2p-chat/src/reportWebVitals.ts",[],"/Users/josephiannone/Documents/Dev/p2p-chat/src/App.tsx",[],"/Users/josephiannone/Documents/Dev/p2p-chat/src/components/Chat.tsx",["35","36","37","38","39","40"],"import React, { Component } from 'react'\nimport Peer from 'peerjs' \nimport moment from 'moment';\nimport CryptoJS from 'crypto-js';\nimport { Box, Badge, Button, List, ListItem, ListItemText, ListItemIcon } from '@material-ui/core';\nimport CommentIcon from '@material-ui/icons/Comment';\nimport FiberManualRecordIcon from '@material-ui/icons/FiberManualRecord';\nimport Grid from '@material-ui/core/Grid';\nimport MessagesDisplay from './Messages';\nimport '../style/Chat.css';\n\n\ntype ChatProps = {\n  localPeer: Peer\n}\n\ninterface Connections {\n  [key: string]: any\n}\n\ninterface User {\n  username: string,\n  peerID: string,\n  _id: string\n}\n\ninterface Message {\n  message: { username: string, message: string},\n  from: string,\n  timestamp: string,\n  seen: Boolean\n}\n\ninterface Messages {\n  [key: string]: Message[]\n}\n\ntype ChatState = {\n  remotePeers: User[],\n  localPeer: Peer,\n  localPeerID: string,\n  selectedRemotePeer: User,\n  textMessage: string,\n  connections: Connections,\n  messages: Messages,\n  isLoggedIn: Boolean,\n  username: string,\n  lastMessage: Message|{}\n}\n\n/************************************************************************\n * This component handles remote peer discovdery, connections, and \n * messages between peers\n */\nclass Chat extends Component<ChatProps, ChatState> {\n\n  // variable to hold interval for remote peer discovery\n  private updateRemotePeersInterval : number = 0;\n  private CLIENT_KEY : string = 'AfxKcLYZTn9SWcDZL';\n  private chatWindowRef : React.RefObject<HTMLDivElement>|null  = React.createRef();\n\n  constructor(props: ChatProps | Readonly<ChatProps>) {\n\n    super(props);\n\n    this.state = {\n      remotePeers: [],\n      localPeer: this.props.localPeer,//\n      localPeerID: '',\n      selectedRemotePeer: {username: '', peerID: '', _id: ''},//\n      textMessage: '',//\n      connections: {},\n      messages: {},//\n      isLoggedIn: false,\n      username: '',\n      lastMessage: {}\n    };\n\n    \n    this.handleRemotePeerChange = this.handleRemotePeerChange.bind(this);\n    this.connectToPeer = this.connectToPeer.bind(this);\n    this.sendMessage = this.sendMessage.bind(this);\n    this.handleMessageChange = this.handleMessageChange.bind(this);\n    this.updateSeenStateOnPeerMessages = this.updateSeenStateOnPeerMessages.bind(this);\n  }\n\n  componentDidMount() {\n    \n\n    /**\n     * Check if logged in\n     */\n    fetch(\"/check\")\n    .then(res => res.json())\n    .then((result) => {\n      if (this.exists(result.username)) {\n        this.setState({ isLoggedIn: true, username: result.username });\n        let messages: string|null = localStorage.getItem(CryptoJS.SHA256(`${result.username}-messages`).toString(CryptoJS.enc.Base64));\n        if (messages !== null) this.setState({messages: JSON.parse(CryptoJS.AES.decrypt(messages, `${this.CLIENT_KEY}${result.username}`).toString(CryptoJS.enc.Utf8))});\n        \n      } else {\n        window.location.href = \"/login\";\n      }\n    }, (error) => {\n      //window.location.href = \"/login\";\n    })\n\n    \n    \n    // get local peer id from peer server\n    this.state.localPeer.on('open', (peerid) => {\n      this.setState({localPeerID: peerid});\n      //assocciate peer id to username on server side\n      this.setUserPeerID(peerid);\n      // retrieve remote peers\n      this.getRemotePeers();\n    });\n\n    // listen for connections\n    this.state.localPeer.on('connection', (conn) => {\n\n      // message receiver\n      conn.on('data', (data) => {\n        // received\n        this.updateRemotePeerMessages(data.username, data.message, data.username);\n      });\n      \n      // connection receiver\n      conn.on('open', () => {\n        // connected\n        this.state.remotePeers.find((peer, index) => {\n          if (peer.peerID === conn.peer) this.updateRemotePeerConnections(peer.username, conn);\n        });\n        \n      });\n\n    });\n\n    // update remote peers list every second\n    this.updateRemotePeersInterval = window.setInterval(() => {\n      this.getRemotePeers();\n    }, 1000);\n\n\n  }\n\n  scrollToBottom = () => {\n    \n    if (this.chatWindowRef !== null && this.chatWindowRef.current !== null) {\n      this.chatWindowRef.current.scrollIntoView({ behavior: \"smooth\" });\n    }\n  };\n\n  componentWillUnmount() {\n    // clear this interval before unmounting\n    clearInterval(this.updateRemotePeersInterval);\n  }\n\n  /**\n   * Peer discovery method\n   */\n  getRemotePeers() {\n    fetch(\"/peers\")\n    .then(res => res.json())\n    .then((result) => {\n      // establish new connection if there is a change in peerid of existing connection\n      result.map((peer: any) => {\n        if (this.exists(this.state.connections[peer.username])) {\n          if (peer.peerID !== this.state.connections[peer.username].peer) this.connectToPeer(peer);\n        }\n      });\n      if (JSON.stringify(result) !== JSON.stringify(this.state.remotePeers)) this.setState({remotePeers: result});\n    }, (error) => {\n      console.log(error);\n    });\n  }\n\n  setUserPeerID(peerid: string) {\n    fetch('/updatepeerid', {\n      method: 'POST', \n      body: JSON.stringify({ \n        username: this.state.username,\n        peerid: peerid\n      }), \n      headers: {'Content-Type': 'application/json'}\n    })\n    .then(response => response.json())\n    .then(result => {\n      console.log('Success:', result);\n    })\n    .catch(error => {\n      console.error('Error:', error);\n    });\n  }\n\n  updateSeenStateOnPeerMessages(peer: User) {\n    if (this.exists(this.state.messages[peer.username])) {\n      this.state.messages[peer.username].forEach((message, index) => { this.state.messages[peer.username][index].seen = true; } )\n      localStorage.setItem(\n        CryptoJS.SHA256(`${this.state.username}-messages`).toString(CryptoJS.enc.Base64), \n        CryptoJS.AES.encrypt(JSON.stringify(this.state.messages), `${this.CLIENT_KEY}${this.state.username}`).toString()\n      );\n      this.setState({messages: this.state.messages}, () => {\n        this.scrollToBottom();\n      });\n     \n    }\n  }\n  \n  handleRemotePeerChange = (event: React.MouseEvent, peer: User) => {\n    this.setState({selectedRemotePeer: peer});\n    this.updateSeenStateOnPeerMessages(peer);\n    this.connectToPeer(peer);\n  }\n\n  updateRemotePeerConnections(username: string, conn: Object) {\n    this.state.connections[username] = conn;\n    this.setState({connections: this.state.connections}, () => {\n      this.scrollToBottom();\n    }); \n  }\n\n  updateRemotePeerMessages(username: string, textMessage: string, remotePeerIndex: string) {\n\n    if (!this.exists(this.state.messages[remotePeerIndex])) this.state.messages[remotePeerIndex] = [];\n\n    let message = {\n      message: {message: textMessage, username: username}, \n      timestamp: moment().format('YYYY-MM-DD HH:mm:ss'), \n      from: username, \n      seen: (this.state.selectedRemotePeer.username === username)\n    };\n    this.state.messages[remotePeerIndex].push(message);\n  \n    localStorage.setItem(\n      CryptoJS.SHA256(`${this.state.username}-messages`).toString(CryptoJS.enc.Base64), \n      CryptoJS.AES.encrypt(JSON.stringify(this.state.messages), `${this.CLIENT_KEY}${this.state.username}`).toString()\n    );\n    this.setState({messages: this.state.messages, lastMessage: message}, () => {\n      this.scrollToBottom();\n    });\n    \n  }\n\n  connectToPeer(user: User) {\n    \n    var conn = this.props.localPeer.connect(user.peerID);\n \n    conn.on('open', () => {\n      this.updateRemotePeerConnections(user.username, conn);\n    });\n\n    conn.on('data', (data) => {\n      this.updateRemotePeerMessages(data.username, data.message, data.username);\n    });\n    \n  }\n\n  sendMessage = (event: React.MouseEvent) => {\n    this.state.connections[this.state.selectedRemotePeer.username].send({username: this.state.username, message: this.state.textMessage});\n    this.updateRemotePeerMessages(this.state.username, this.state.textMessage, this.state.selectedRemotePeer.username);\n    this.setState({textMessage: ''});\n  }\n\n\n  handleMessageChange = (event: React.ChangeEvent) => {\n    this.setState({textMessage: (event.target as HTMLInputElement).value});\n  }\n\n  \n  exists(v: any) {\n    if (typeof v !== 'undefined') return true;\n    else return false;\n  }\n\n\n  render() {\n    \n    const { username, remotePeers, connections, textMessage, selectedRemotePeer, messages, localPeerID, lastMessage } = this.state;\n    \n    return (\n      <Grid container spacing={0}>\n\n        <Grid item xs={12} sm={8}>\n          <Box id='chat-window-container' >\n            <Box id='chat-window'>\n              <List>\n              {this.exists(connections[selectedRemotePeer.username]) ? \n                <ListItem dense style={{color: 'green'}}>Connection opened with <b>&nbsp;{selectedRemotePeer.username}</b></ListItem> : \n                <></>\n              }\n              {this.exists(messages[selectedRemotePeer.username]) ?\n                <>\n                  <MessagesDisplay\n                    messages={messages[selectedRemotePeer.username]}\n                    localUsername={username}\n                    lastMessage={lastMessage}\n                  />\n                </>\n              : ''\n              }\n              </List>\n              <div ref={this.chatWindowRef}></div>\n            </Box>\n            {this.exists(connections[selectedRemotePeer.username]) ?\n            <Box boxShadow={1} id={'text-send-region-container'} style={{borderTop: '1px #d3d3d3 solid'}}>\n              <Grid container spacing={0} id={'text-send-container'}>\n                <Grid item xs={8}><textarea style={{width: '100%', resize: 'none'}} value={textMessage} onChange={this.handleMessageChange} rows={2}></textarea></Grid>\n                <Grid item xs={2}><Button disableElevation variant=\"contained\" color='primary' onClick={this.sendMessage} >Send</Button></Grid>\n              </Grid>\n            </Box> : ''\n            }            \n          </Box>\n        </Grid>\n        <Grid item xs={12} sm={4} style={{borderLeft: '1px #d3d3d3 solid'}} >\n          \n            \n          <List key={JSON.stringify(remotePeers)} disablePadding>\n          {(remotePeers.length < 2) ? \n            <ListItem disabled>No Peers Available</ListItem> :\n            <>\n            {remotePeers.map((peer: User) => {\n              if (peer.username === username) return '';\n              \n              var unreadCount = 0;\n              var hasMessages = false;\n              if (this.exists(messages[peer.username])) {\n                hasMessages = true;\n                unreadCount = messages[peer.username].filter((message) => peer.username === message.from ? message.seen === false : false).length;\n              }\n\n              return (\n                <ListItem key={JSON.stringify(peer)} button selected={selectedRemotePeer.username === peer.username} onClick={(event) => this.handleRemotePeerChange(event, peer)}>\n                {this.exists(connections[peer.username]) ? \n                  <>\n                  <ListItemIcon>\n                    <FiberManualRecordIcon fontSize='small' style={{color: 'green'}} />\n                  </ListItemIcon>\n                  <ListItemText primary={peer.username} />\n                  {hasMessages ? <Badge badgeContent={unreadCount} color=\"secondary\"><CommentIcon fontSize='small' color='primary' /></Badge> : ''} \n                  </>: \n                  <ListItemText primary={peer.username} />\n                }\n                </ListItem>\n              )\n            })}\n            </>\n          }\n          </List>\n        </Grid>\n        \n\n      </Grid>\n    );\n  }\n\n}\n\n\n\nexport default Chat;","/Users/josephiannone/Documents/Dev/p2p-chat/src/components/LoginForm.tsx",[],"/Users/josephiannone/Documents/Dev/p2p-chat/src/components/Messages.tsx",["41"],"import { Component } from 'react'\nimport moment from 'moment'\nimport { ListItem, Grid } from '@material-ui/core';\nimport AccountCircleIcon from '@material-ui/icons/AccountCircle';\n\ninterface Message {\n  message: { username: string, message: string},\n  from: string,\n  timestamp: string,\n  seen: Boolean\n}\n\ntype MessagesProps = {\n  messages: Message[],\n  localUsername: string,\n  lastMessage: Message|Object\n}\n\n\n\n/************************************************************************\n * \n */\nclass MessagesDisplay extends Component<MessagesProps> {\n\n\n  constructor(props: MessagesProps | Readonly<MessagesProps>) {\n\n    super(props);\n\n  }\n\n  shouldComponentUpdate (nextProps: MessagesProps) {\n    // optimization so we only rerender if a message is added\n    return (this.props.lastMessage !== nextProps.lastMessage);\n  }\n\n\n\n  render() {\n    return (\n      <>\n      {this.props.messages.map((message, index) => {\n        return (\n          <ListItem dense key={`${JSON.stringify(message)}-${index}`}>\n            <Grid container justify=\"flex-start\" direction=\"row\">\n              <Grid item xs={1}><AccountCircleIcon style={{float: 'left'}} color={message.from === this.props.localUsername ? 'primary':'secondary'} fontSize={'large'} /></Grid>\n              <Grid item xs={11} className={'messageDisplaycontainer'}>\n                <div>\n                  <span className='messageDisplayName'>{message.from}</span>\n                  <span className='messageDisplayTS'>{moment(message.timestamp).format('M/D/YY h:mm a')}</span>\n                </div>\n                <div className='messageDisplayMSG'>{message.message.message}</div>  \n              </Grid>\n            </Grid>\n          </ListItem>\n        );\n      })}\n      </>\n    );\n  }\n\n}\n\n\n\nexport default MessagesDisplay;",{"ruleId":"42","replacedBy":"43"},{"ruleId":"44","replacedBy":"45"},{"ruleId":"46","severity":1,"message":"47","line":131,"column":51,"nodeType":"48","messageId":"49","endLine":131,"endColumn":53},{"ruleId":"46","severity":1,"message":"50","line":167,"column":30,"nodeType":"48","messageId":"49","endLine":167,"endColumn":32},{"ruleId":"51","severity":1,"message":"52","line":198,"column":72,"nodeType":"53","endLine":198,"endColumn":113},{"ruleId":"51","severity":1,"message":"52","line":217,"column":5,"nodeType":"53","endLine":217,"endColumn":27},{"ruleId":"51","severity":1,"message":"52","line":225,"column":61,"nodeType":"53","endLine":225,"endColumn":80},{"ruleId":"54","severity":1,"message":"55","line":279,"column":92,"nodeType":"56","messageId":"57","endLine":279,"endColumn":103},{"ruleId":"58","severity":1,"message":"59","line":27,"column":3,"nodeType":"60","messageId":"61","endLine":31,"endColumn":4},"no-native-reassign",["62"],"no-negated-in-lhs",["63"],"array-callback-return","Array.prototype.find() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","Array.prototype.map() expects a return value from arrow function.","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","@typescript-eslint/no-unused-vars","'localPeerID' is assigned a value but never used.","Identifier","unusedVar","@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","no-global-assign","no-unsafe-negation"]